package plugins.cddb;

//import com.antelmann.io.MyFile;
import java.io.Serializable;
import java.text.ParseException;
import java.util.Properties;


/**
* CDDBEntry represents an entry for a CD in a CDDB database
* that contains all known properties about the associated CD.
* <p>
* CDDBEntry also contains methods to generate Artist and Composition
* objects to bridge from a CDDB database to a more sophisticated internal
* CD database.
* @author Holger Antelmann
* @see CDDBXmcdParser
* @see Composition
* @see Artist
*/
public class CDDBEntry implements CDInfo, Serializable
{
    /** used for generated Contribution comments or Artist descriptions */
    public static final String DEFAULT_COMMENT = "generated by CDDBEntry";
    CDDBXmcdParser parser;
    CDDBRecord     record;


    /**
    * The fileContent must be in xmcd format specified by CDDB and must contain
    * the discID from the record.
    * @throws ParseException if the fileContent is not in valid xmcd format
    *                        or inconsistent with the given record
    */
    public CDDBEntry (CDDBRecord record, String fileContent) throws ParseException {
        this.record = record;
        parser = new CDDBXmcdParser(fileContent);
        String[] ids = parser.readDiscIDs();
        for (int i = 0; i < ids.length; i++) {
            if (ids[i].equals(record.getDiscID())) return;
        }
        throw new ParseException("discID in record not found int fileContent", -1);
    }


    public String getXmcdContent () { return parser.getContent(); }


    public CDDBRecord getCDDBRecord () { return record; }


    public CDID getCDID () {
        return new CDID(record.getDiscID(), parser.readOffsets(), parser.readLength());
    }


    public Properties getProperties () {
        Properties prop = new Properties();
        prop.put("record.category", record.getCategory());
        prop.put("record.discid", record.getDiscID());
        prop.put("record.title", record.getTitle());
        prop.putAll(parser.getProperties());
        return prop;
    }


    /**
    * saves the content of the entry into a file in the given directory
    * according to standard CDDB conventions. <p>
    * The file will be saved in a subdirectory specified by the category and
    * the filename will be the discID. The file content is the raw CDDB format.
    * If the file already exists, an IOException will be thrown.
    */
    /*public void saveToDirectory (File dir) throws IOException
    {
        File subdir = new File(dir, record.getCategory());
        MyFile file = new MyFile(subdir, record.getDiscID());
        if (file.exists()) throw new IOException("file already exists");
        subdir.mkdirs();
        file.writeText(parser.getContent(), false);
    }*/



    /**
    * creates a default Composition object from the embedded CDInfo that
    * regards the entire CD as one composition and will contain certain
    * Composition objects as far as applicable.
    * @param includeTracks if true, the generated Composition object
    *                      will already contain all tracks from the
    *                      embedded CDInfo
    */
    public Composition extractComposition (boolean includeTracks) {
        Composition comp = new Composition(
            parser.readCDTitle(),
            Genre.getGenre(parser.readGenre()),
            parser.readExtension(),
            null
        );
        Artist artist = extractCDArtist();
        if (artist != null) {
            comp.add(new Contribution(artist, Role.ARTIST, 0, DEFAULT_COMMENT));
        }
        comp.setRecordingYear(parser.readYear());
        if (includeTracks) {
            Track[] t = extractTracks(true);
            for (int i = 0; i < t.length; i++) {
                comp.add(t[i]);
            }
        }
        return comp;
    }


    /**
    * generates default Track objects that - if addArtist is true -
    * contain applicable contributions
    */
    public Track[] extractTracks (boolean addArtist) {
        int n = parser.readNumberOfTracks();
        Track[] track = new Track[n];
        for (int i = 0; i < n; i++) {
            track[i] = new Track(getCDID(), i, parser.readTrackTitle(i),
                parser.readTrackExtension(i));
            if (addArtist) {
                Artist artist = extractTrackArtist(i);
                if (artist != null) track[i].add(
                    new Contribution(artist, Role.ARTIST, 0, DEFAULT_COMMENT));
            }
        }
        return track;
    }


    /** returns the artist defined for the CD or null if none was found */
    public Artist extractCDArtist () {
        String name = parser.readArtist();
        if (name == null) {
            return null;
        } else {
            return new Artist(name, DEFAULT_COMMENT);
        }
    }


    /** returns the artist defined for the track or null if none was found */
    public Artist extractTrackArtist (int track) {
        String name = parser.readTrackArtist(track);
        if (name == null) {
            return null;
        } else {
            return new Artist(name, DEFAULT_COMMENT);
        }
    }
}
